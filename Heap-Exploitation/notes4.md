What target should we pick in order to get a shell?
--------------------------------------------------
We could target the binary, 
Tampering with structures like the **PLT** or **fini array** can yield code execution.
the procedure linkage table, or PLT, is a writable array of function pointers,
every function the program calls, that resides in an external library like GLIBC, 
is represented in the PLT.
The reason it remains **writable** for the program's lifetime is to support something called **lazy linking**,
whereby a function's address is only resolved **when it's first called**.
Overwriting PLT entries is a great way to hijack the flow of execution.

**libc** also has a **procedure linkage table** alongside two other structures called **__exit_funcs** and
**tls_dtors** which behave similarly to the **fini array**.
But although the **GLIBC PLT** is writable throughout the program lifetime, it can be difficult to trigger calls to the functions within it.
What's more, both **__exit_funcs** and **tls_dtors** are protected by something called **Pointer Guard**
which makes reliably tampering with them somewhat difficult.

However, it turns out that there is a heap-specific way to hijack the flow of execution, I'm talking about the **malloc hooks**.

Each of malloc's core functions, such as malloc() and free(), has an associated hook which takes the form of a writable function pointer in GLIBC's data section

One advantage of using the free hook is that it's first and only argument will always be a pointer to chunk user data, meaning that if we overwrite the free hook with the address of GLIBC's system() function, then freeing a chunk that contains our command string becomes the equivalent of passing that command to system().


**Arenas** are structures in which malloc keeps all of its **non-inline metadata**, consisting primarily of the **heads** of each of those **free lists** I mentioned. A single **arena** can administrate multiple heaps and a new arena is created along with an initial heap every time a **thread** uses malloc for the first time, up to a limit based on the number of available cores.

**The main thread** gets a special arena called the **main arena**, which resides in the **libc data section**.
And it's the main arena that pwndbg is getting its current information from.

the string "/bin/sh" actually exists within the GLIBC shared object.
The reason for this is that functions like system() already do the equivalent of run /bin/sh via the execve syscall which is then used to run the command passed by the program.
We can use the existing "/bin/sh" string in the libc shared object like so. 
`next(libc.search(b"/bin/sh")`

If we want more information on a struct, we can use GDB's `'ptype'` command to inspect it, which shows


`find_fake_fast addr_val`- can help locate viable fake chunks that qualify for the **fastbins**.
When allocating from the **fastbins**, malloc does not check for **alignment**, nor does it check that a chunk's **flags** are valid.
Some flag combinations can cause a crash, but 0x0f will work just fine.

on most x86 Linux platforms, libraries are always mapped at addresses starting with 0x00007f. We can use this fact to pass checks like above
by picking an offset from an address such that its size field is 0x7f


**One-Gadget**
-------------- 
From the system() man page we can see that all system() does is use execl(), which is a wrap around execve(), 
This means that there must exist in the GLIBC shared object
some code that does the equivalent of execve("/bin/sh") i.e. drop a shell.
And these code snippets are known as one-gadgets

Search for & print any one-gadgets in the GLIBC binary that `<target program>` was linked against: 
```$ one_gadget $(ldd <target program> | grep libc.so | cut -d' ' -f3)```


to run /bin/sh with the '-c' option followed by the command passed as an argument.

**Full RELRO**: we'll have to rely on the malloc hooks to get code execution rather than on the binary..
**position-independent (PIE)**, meaning that we don't
know the location of the binary in memory.
Note that position-independent programs use **different base addresses for the binary and heap**, **even when running without ASLR enabled**,
If you've been experimenting with **dash**, you'll have noticed that it's sensitive to malformed arguments. Passing a nonexistent option or file name to it will not result in a shell.
What's worse is that even if the first argument is valid, it will continue to parse arguments until it hits a null, failing on any that are malformed or unreadable.
If you've been browsing the dash man page, however, you may have discovered a couple of solutions to this problem.
The first is that if dash comes across a valid file name, it will attempt to parse it for further commands, ignoring any succeeding arguments.
So, If you're able to write your commands to disk, then this is a viable option.
A second, perhaps more practical solution is to pass the
'-s' argument which starts reading commands from stdin, ignoring any succeeding arguments.

chown root:root fastbin_dup_2
sudo chmod +s fastbin_dup_2

To link a binary against a specific GLIBC build you can do both of the following (I use the GNU Compiler Collection - **GCC**):
Pass the `-rpath=<path to your libc.so binary>` option to the linker (you can use `-Wl` to pass options to the linker via gcc).
Pass the `-dynamic-linker <path to your ld.so binary>` option to the linker (again you can do this via `-Wl`.

**Building GLIBC** is relatively easy, you can clone the repo from git://sourceware.org/git/glibc.git and it comes with a makefile which does most of the heavy lifting.
If you want relative paths to your source code you can pass the `-fdebug-prefix-map` option to the compiler, I just **patch that in to my GLIBC makefile**.

**Linking binaries** to a specific GLIBC build just involves passing the `-rpath` and `-dynamic-linker` options to the linker. You can pass them relative paths if you want to make things more portable.

the only difference between the so-called **tcache bins** and the **fast bins**, aside from the maximum size they hold, is that tcache bins reference chunks by the address of their user data rather than their metadata.

Tcache/s are basically miniature arenas that are allocated on the heap itself, they hold chunks


mp – print the mp struct (tcache paramerters)

If you're operating locally, you can influence a handful of glibc, internal limits, including tcache count using environment variables.

They're more of a curiosity since they're ignored in **suid** and **sgid** binaries

Calloc doesn’t allocate from the tcache

When a chunk is allocated from the fastbins, Malloc dumps any remaining chunks in that fast bin into its corresponding tcachebin until full.
This behavior also applies to the smallbins, the unsortedbin does this too, although instead of selecting a chunk to allocate and then dumping chunks into the tcache, it dumps exact fitting chunks **right away**, **then**- **either** allocates the **last exact fitting** chunk it finds or grabs one from the recently filled tcachebin.

Don't forget that tcache dumping also allows you to move chunks into the cash from these small bins and unsorted bin, and that calloc ignores the tcache entirely, opening up many more possibilities.

Man mallopt -> search for /env
Mallopt is a function used to control some of malloc parameters at runtime, We can see from its man page that, for example, setting the malloc **mmap threshold** environment variable would allow us to control the mmap threshold - perhaps useful in a **house of rabbits exploit**.
you can, of course, set your chosen environment variable in one of the
usual ways per program or special session.
You could also set it from within GDB, which can help determine its effect.
Be aware that **mallopt** parameters set via **environment variables** only take effect once malloc has been initialized.
Another interesting environment variable is one called a **glibc tunable**, these so-called tunable cover
various glibc parameters, including those of malloc.
Rather than each tunable having its own environment variable, they are passed to glibc as a colon separated list in the glibc tunable variable.


*TODO: Needs a re-write*

A quick way to look up which tunaables are available is to dump the tunable list array from within GDB.
There is some overlap with the individual environment variables, the mmap thresholds can also be set by a glibc each universals, but there are some unique tunable.
For example, entry 21 in the tunable list is named **tcache count**, unsurprisingly, responsible for setting the Tcache count value in Malloc moppy struct.
You can use this tunable to set that cash count to any value you please, setting it to zero effectively disables the tcache.
One interesting aspect of the glibc tunable environment variable is that its contents can be altered by Glibc to allow this to work.
The variable is copied into its own space.
This space is reserved by its break out program initialization.
If I dump memory at the beginning of the heap mapping.
We can see the variable before the start of the heap.
This value here is that he cash chunks Sarsfield.
glibc tunable get mapped here, whether they're valid or not, so you can use this to influence the default heap start address.

Unfortunately, while these environment variables appear useful from a local exploitation point of view, they are **ignored** when there's a discrepancy between user or group ID and extended user or group ID,
for example, in a set user ID binary.
What's more, if a tunable has a security level of a raise as to cash count, does it's considered too unsafe to posterchild processes and set user ID binaries will erase it from the environment altogether.

If you do find an exploitation vector that is foiled by this last mitigation, perhaps a set user ID binary that sets its user ID to match its extended user ID before invoking a vulnerable child process,
then know that there is a **bug** in this implementation.
Including the **same tunable twice** in the glibc tunable environment variable is enough to get your chosen
tunable past to a child protest from a set user ID binary.
(Bug has been reported)

