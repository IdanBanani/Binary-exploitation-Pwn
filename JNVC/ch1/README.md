## Challenge 1

#### Description
The following instructions taken from an Android device. What it does?


#### Rules
None.

#### Code
```asm
loc_0000
.text:0000000000000000          MOV     X8, #0x40
.text:0000000000000004          SVC     0
.text:0000000000000008          CMN     X0, #1, LSL#12
.text:000000000000000C          B.HI    __set_errno_internal RET
.text:0000000000000010          RET
```

## Solution:
----
This code is very similar to a code from Android libc:  
[https://android.googlesource.com/platform/bionic/+/011e111/libc/arch-arm64/syscalls/write.S](https://android.googlesource.com/platform/bionic/+/011e111/libc/arch-arm64/syscalls/write.S)  
Which was generated by this script for templates:  
[https://android.googlesource.com/platform/bionic/+/master/libc/tools/gensyscalls.py](https://android.googlesource.com/platform/bionic/+/master/libc/tools/gensyscalls.py)  
So basically this is a user-space syscall gate/proxy  

A good resource: [https://eastrivervillage.com/Anatomy-of-Linux-system-call-in-ARM64/](https://eastrivervillage.com/Anatomy-of-Linux-system-call-in-ARM64/)  

#### "Static analysis":  
##### Things to note:
- Arm 64 bit arch (Using X registers)
- each instruction occupies 4Bytes = 64 bit in memory 
#####Calling convention
```
The 64-bit ARM (AArch64) calling convention allocates the 31 general-purpose registers as: ......
```
##### What we actually care about here:
```
x8 (XR): Indirect return value address.
x0 to x7: Argument values passed to and results returned from a subroutine.
```

Lets translate the code to "Intermidiate language"

` MOV     X8, #0x40 `   
X8 = 0x40h = 64 = sys_write (AArch64 Write syscall number)  

` SVC 0 `  
[Supervisor call] will result in executing write system call

But what arguments are we sending?
They actually were set beforehand by the user who invoked this library function.
```c
ssize_t write(int fd, const void *buf, size_t count);
```
So the destination file descriptor is **X0**  
The buffer to be written address is **X1**   
And number of bytes that will be written from buf to fd is **X2** 
Unlike standart Linux we have are going to have the following behaviour for write() :
>  On success, the number of bytes written is returned.  
On error, -1 is returned, and errno is set to indicate the error.

**X0** will now hold the returned value from the syscall

` CMN     X0, #1, LSL#12 `  
Q: Why do we need such command?  
A: Because encoding negative a immidiate in the operand2 format is not supported

Q: How does compare works?   
A: It does subtraction. meaning calculating X0 -(-(2^12) = X0 + 2^12
[Theoretically an overflow might happen if X0 > (2^64 - 2^12) 
TODO: need to test it]   

[Link to an explanation for why MAX_ERRNO = 2^12 - 1 = 4095](https://stackoverflow.com/questions/47551940/aosp-non-obvious-syscall-implementation)  

This might be relevant also:  
[Link 1](https://www.javaer101.com/en/article/14858403.html)  
[Link 2 - syscall.h](https://github.com/torvalds/linux/blob/master/arch/arm64/include/asm/syscall.h#L33)  
`
#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)
 ` [from include/linux/err.h]

Now - What we want here to happen is that in case of negative return value in the range of -(MAX_ERRNO) to -1 is that ERRNO (global var) will be set to |X0| (absolute value) which is done with the help of  the omitted command from the original source code: `cneg    x0, x0, hi`  
(X0 = -X0 if "last result was higher than zero" which means we got an error) and ` __set_errno_internal ` [**ERRNO** will have the (positive) value of **X0**]  

NOTE: We might think that CMN will Compare the returned value in **X0** to -(1 * 1 << 12) by [which but it actually checks if (-2^12 + 1) <= X0 <= -1  
(the valid error code range)
##### TODO: Check why and debug it on QEMU/ radare2 ESIL, because I fail to explain this

` B.HI    __set_errno_internal RET `  
This is actually a typing error, it should be  
` B.HI    __set_errno_internal`

If we won't add the  ` cneg    x0, x0, hi ` then the logic will stay the same, but ERRNO will be set to a negative value in case of an error.

if **X0** was non-negative [success] or **<= -4096** then we will skip this branch and return **X0**