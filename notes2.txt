glibc has better protections than most libc distributions

when malloc chunk's IS_MMAPPED flag == 1:
When malloc receives a request larger than a variable named "mmap_threshold", the request will be
serviced via the GLIBC mmap() function rather than from an arena.

data section of a binary is Non poisition independent !

if we have an arena leak which is the main areana , that's also a libc leak.

libc has its own plt alongside two other structures called __exit_funcs & tls_dtor_list

glibc plt is writeable throughout the program lifetime, but it's hard to trigger calls to the functions within it

 __exit_funcs & tls_dtor_list are protected by Pointer guard

 malloc hooks (malloc core functions = func pointer in glibc data section)

you need a guard chunk (>=0x20) to avoid consolidation with the top chunk (or a fencepost of size 0x10)

Tcache
---------------------
calloc doesn't use the tcache (it won't allocate chunks from there)

useful for one_gadget
https://libc.rip/
https://github.com/niklasb/libc-database

in 64 operations on 32 bit registers clear the most significant bits of the corresponding 64 bit register.

Exploitation methods notes:
-----------------------------
house of force - no integrity check on the size field of the top chunk