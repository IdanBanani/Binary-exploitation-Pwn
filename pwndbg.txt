malloc_chunk &fake_chunk_on_stack  - malloc perspective of a chunk (including flags)
info file (shows elf info)

!dq - run the latest dq command
mp - print malloc configuration /parameters
dq mp_.sbrk_base 64 - dump the default heap memory
context backtrace - show calls backtrace

malloc_chunk chunk_addr - print information on a malloc chunk (parse it)

ptype mp_ - print malloc parameters
p/x mp_ - print the content in hex

mallopt - change malloc parameters (not always available)

sudo gdb --pid $(pgrep firefox)   = attach gdb to firefox
p _IO_list_all - > gives the head of the linked list = last file that was opened
p _IO_list_all.file._chain

dq &main_arena.bins

rwatch hook_name - set a hardware breakpoint
		 Set a watchpoint that will break when the value of hook_name is read by the program.

record - prompts GDB to log every executed instruction, allowing us to undo our mistake afterwards.
	GDB seems to have problems breaking during recorded read operations when the target is remote.
	To counter this, set a break point on the put s function, which the program uses to print parts of its menu.
	with record mode active, We can step not just forward, but backwards as well by adding the
	 reverse prefix to some of GB's commands.
	What makes this so powerful is that breakpoints also work when executing in reverse and GDB will record
	user input, which is replayed when execution continues in the forward direction.
	allowing us to try an alternative path without having to start the whole program over

record goto begin

record delete - GDB will replay our user input if we continue execution in the forward direction.
		To avoid this, we can delete the execution log with record delete.

record stop

ignore breakpoint_num for_how_many_times


u __free_hook - dissassemble asm instructions at a symbol/addr (check that hook was successfully override with do_system)
equ addr value - set memory at addr to value (like set)

ds addr - decode int to string
if we have an arena leak which is the main areana , that's also a libc leak.

p &main_arena.bins - all bins addresses are stored in this array (mchunkptr), starting with the unsorted bin

^fd^bk -run the previous command while replaced the keyword fd with bk

gdb binary_name
> start - ensure the libraries are loaded
> ptype /o struct _IO_FILE- print info for a glibc type , /o for offset of each member
> dt FILE -dump type command (neater output)
> dt "struct _IO_FILE" (spaces requires "")
> dt "struct _IO_FILE_plus" (spaces requires "")
pwntools has house of orange inside it:
2.13 pwnlib.filepointer â€” FILE* structure exploitation

pwn.context.terminal = ["tmux", " splitw"]

breakrva addr
binascii.a2b_hex

strings in decompiler
flow in dissasmbler

cyclic -l stringToserachAndReturnOffset
info functions
run < payload.txt

info(%#x target,elf.symbols.ret2win)

io.wait() - wait for the application to crash
core = io.corefile
eip_Value = core.eip
eip_offset = cyclic_find(eip_value)
asm('nop')
payload = flat(x,y,z)

io = start()  ---> start the program(binary)
pattern = core.read(core.rsp,4)
payload = fit({pattern : elf.symbols.ret2win}) # create a new payload which puts the target
                                                 at the correct offset

pwn.cyclic_find(pattern,n=num of bytes)
                                                 
gdb:
init-peda

peda:
pattern_search

radare
rabin -i filename (import)

rabin -qs file | grep -ve imp -e ' 0 ' [interesting functions]

rabin2 -z file [programmer strings]

radate2 filename
s sym.
pdd
s sym.symbolname
pdd = dissassemble

set context-sections regs disasm args code stack backtrace
context-stack-lines, context-code-lines
dumpargs (Context: showing function args)
entry - break at first executed instruction
nextjump
nextsyscall
nextret
stepjump
stepret
vmmap = gdb's info proc mappings
proc info
set emulate off/on (Emulates code up to the closest branch/call)
