pwndbg docs - https://browserpwndbg.readthedocs.io/en/docs/

Useful common commands:

show/search commands:
--------------------------------
pwndbg
pwndbg search-term

general (CLI scripting and analysis):
----------------------
print/p a - print value of variable/symbol a
quit/CTRL-D
set {int}addr1 = addr2 (gdb)

pwn.context.terminal = ["tmux", " splitw"] - inside your python pwntools script - use Tmux terminal
!dq - run the last dq command
^fd^bk -run the previous command while replacing the keyword fd with bk
info file (shows elf info)
info functions

To inspect instructions at the address the malloc hook points to you can omit the ampersand altogether like this
dissassemble asm instructions at a symbol/addr (to check that hook was successfully overriden with do_system):
pwndbg> u __malloc_hook
pwndbg> u __free_hook -
run < payload.txt - run the binary loaded to gdb with args from a file
breakrva addr - break at relative virtual addr from PIE base 
strings in decompiler
flow in dissasmbler

navigating while debugging
----------------
entry - break at first executed instruction
nextjump -
nextsyscall - 
nextret - Breaks at next return-like instruction
stepjump - 
stepret - Breaks at next return-like instruction by 'stepping' to it
cyclic -l stringToserachAndReturnOffset - (usually for buffer overflows attacks)

Virtual memory space:
----------------------
vmmap = gdb's info proc mapping
proc info

set emulate off/on (Emulates code up to the closest branch/call) ???

Malloc chunks parsing:
----------------
malloc_chunk &fake_chunk_on_stack  - malloc perspective of a chunk (including flags)
malloc_chunk chunk_addr - print information on a malloc chunk (parse it)

piping in gdb: pwndbg> |heap|grep -A1 Allocated

inspecting memory regions / special structs:
-------------------------
vis - nicely visualize the (main?) heap [will succeed unless meta-data is too much coruppted by an attacker] 
Vis x – print only the first x chunks on the heap
A quick way to find the start of the default heap:
dq mp_.sbrk_base num_of_qwords - dump the default heap memory (dq for dump quadword- 8byte units)
dq &main_arena 20
dq &main_arena.bins
p &main_arena.bins - all bins addresses are stored in this array (mchunkptr), starting with the unsorted bin
dq &__malloc_hook-2 start dumping 2 quadwords before symbol
db = dumpbytes (like hexdump)
p *((struct malloc_chunk*)addr).fd


debugging/ root cause analysis / post mortem:
----------------------
reached abort() -> we invoked some of libc heap mitigations
use f/frame to check what happend
f 4 = switch to frame _int_free()

context [subcontext [subcontext ...]] - subcontext: 'reg', 'disasm', 'code', 'stack', 'backtrace', and/or 'args'
context backtrace - show calls backtrace
set context-sections regs disasm args code stack backtrace - you choose what sections to display currently

context-stack-lines, context-code-lines - tune (change) display parameters
context all 
dumpargs (Context: showing function args while inside of a function)

malloc parameters & tunables:
----------------------
mp - print malloc configuration /parameters
ptype mp_ - print malloc parameters
p/x mp_ - print the content in hex
mallopt - change malloc parameters (not always available)

man mallopt -> then /env (go to env section)
you can modify environment variables  per program / per shell session (export)
or from gdb : set environment varname =
malloc paramerters which are set through environment variables takes effect only once mallloc has been initialized	


Show currently executed c code after setting the view size 
Set listsize 17 (lines)
List malloc.c:line_number


glibc tunables
p tunable_list[21]

unset environment - ?
set environment GLIBC_TUNABLES = glibc.malloc.tcache_count = 0

gdb invocation:
----------------------
sudo gdb --pid $(pgrep firefox)   = attach gdb to firefox

File stream explotation (e.g House of Orange):
----------------------
p _IO_list_all - > gives the head of the linked list = last file that was opened
p _IO_list_all.file._chain

Right after loading a binary with GDB: (gdb binary_name):
start - ensure the libraries are loaded (such as libc?)

ptype /o struct _IO_FILE- print info for a glibc type , /o is for displaying offset of each member
dt FILE - dump type command (neater output)
dt "struct _IO_FILE" (spaces requires "")
dt "struct _IO_FILE_plus" (spaces requires "")
pwntools has house of orange inside it:
2.13 pwnlib.filepointer — FILE* structure exploitation


HW breakpoints and "Timeless debugging" in GDB (better use Geohot's QIRA or Mozilla's rr)
--------------------------------------------
rwatch hook_name - set a hardware breakpoint
		 Set a watchpoint that will break when the value of hook_name is read by the program.

Watch points are great for finding out when a hook is being used, but to determine whether they're
viable for use with a one_gadget, it's best to corrupt the hook, then wait until execution stops at
the exact point the hook gets called.

record - prompts GDB to log every executed instruction, allowing us to undo our mistake afterwards.
	GDB seems to have problems breaking during recorded read operations when the target is remote.
	(it also ignores hardware watchpoints)
	To counter this, set a break point on the puts function, which the program uses to print parts of its menu.
	with record mode active, We can step not just forward, but backwards as well by adding the
	 reverse prefix to some of GB's commands.
	What makes this so powerful is that breakpoints also work when executing in reverse and GDB will record
	user input, which is replayed when execution continues in the forward direction.
	allowing us to try an alternative path without having to start the whole program over
	
record goto begin

record delete - GDB will replay our user input if we continue execution in the forward direction.
		To avoid this, we can delete the execution log with record delete.

record stop

ignore breakpoint_num for_how_many_times


Modifying memory content
----------------------
equ addr value - set memory at addr to value


Converting between data types
----------------------
ds addr - decode int to string
binascii.a2b_hex (Python, has much more methods)

============  pwntools =================
info(%#x target,elf.symbols.ret2win) - printing log messages to stdout
io.wait() - wait for the application to crash
core = io.corefile
eip_Value = core.eip
eip_offset = cyclic_find(eip_value)
asm('nop')
payload = flat(x,y,z)
io = start()  ---> start the program(binary)
pattern = core.read(core.rsp,4)
payload = fit({pattern : elf.symbols.ret2win}) # create a new payload which puts the target
                                                 at the correct offset
pwn.cyclic_find(pattern,n=num of bytes)
                                                 

============== Other tools ===============

radare (TBC):
----------------------
rabin -i filename (import)
rabin -qs file | grep -ve imp -e ' 0 ' [interesting functions]
rabin2 -z file [programmer strings]
radare2 filename
s sym.
pdd
s sym.symbolname
pdd = dissassemble


peda:
init-peda
pattern_search