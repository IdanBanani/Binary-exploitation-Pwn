## Challenge 6

#### Description
The following code belongs to a remote service.
The goal of this challenge is to find the problem (if there is more than 1, then find all the problems) and describe it fully, including a description of how to exploit it.

[*] Bonus points for compiling it (fully protected - PIE, ASLR, W^X) and writing a fully working exploit (locally).

#### Rules
None.

## Solution (X64):
----------------
The goal here is to open a shell (even better as ש root)

Depending on glibc version and whether tcache is on/off:
old versions - fastbin dup attack (double free)
v2.26/v2.27: - tcache dup attack

v2.28: - tcache dump 
v2.31: - some extra mitigations on size fields etc.

  Override the __free_hook / __malloc_hook / atoi with system() address and create a fake (dup) chunk to point to it.  
  send it "/bin/sh'/0'" as an argument or use one_gadget to solve for a specific glibc build.

----------------------------------------------------------------
### Static analysis:

The first thing to note is the structs:

Each time we'll create an entry, two memory chunkgs will be allocated on the heap: one for the entry, and one for its name
[ age(int) | name(char*)--]--> [actual name str(64B Max)]

----------------
### Theory: 
----------------  
Free chunks are linked directly into their corresponding fastbin if their corresponding tcachebin is full. Fastbin searches are conducted after a tcache search and before any other bins are searched, when the request size falls into fastbin range.

Tcache
### tcache Dup
Overview
Leverage a **double-free** bug to coerce malloc into returning the same chunk twice, without freeing it in between.  
This technique is typically capitalised upon by corrupting **tcache metadata** to **link a fake chunk** into a tcachebin. This fake chunk can be allocated, then program functionality could be used to read from or write to an arbitrary memory location.  

Detail:   
The **Tcache Dup** technique operates in a similar manner to the **Fastbin Dup**, the primary difference being that in GLIBC versions < **2.29** there is no **tcache double-free mitigation**.  
The Tcache Dup is a very powerful primitive because there is **no chunk size integrity check** on allocations from a tcachebin, making it very easy to overlap a fake tcache chunk with any memory address.


Further use
In GLIBC version **2.29** a **tcache double-free check** was introduced:  
A chunk is linked into a tcachebin, the **address of that thread’s tcache** is written into the slot usually **reserved** for a **free chunk’s** **bk pointer**, which is relabelled as a **“key” field**. 

When chunks are freed, their **key** field is **checked** and **if it matches** the **address** of the **tcache** then the appropriate tcachebin is **searched** for the **freed chunk**.  
**If** the chunk is found to be **already in the tcache** then **abort**() is called.  

This check can be **bypassed** by **filling the target tcachebin** to free a (same sized) victim chunk into the **same sized fastbin** afterwards, **emptying** the tcachebin **then** freeing the victim chunk a **2nd time**.  
Next, the victim chunk is **allocated from the tcachebin** at which point a designer can **tamper** with its **fastbin fd pointer**.  
When the victim chunk is allocated from its fastbin, the **remaining chunks** in the **same fastbin** are **dumped** into the **tcache**, including the **fake chunk**, tcache dumping **does not include a double-free check**.  
Note that the fake chunk’s fd **must be null** for this to succeed (TODO: check why).  

Since the tcache itself resides on the heap, it can be subject to corruption after a heap leak.  

----------------------------------------------------------------

Tcache Dumping
In versions of GLIBC compiled with tcache support, chunks in tcache size range are **dumped** into a tcache when a thread is allocated a chunk from its arena.  
When a chunk is allocated from the **fastbins** or **smallbins**, malloc dumps any **remaining free chunks** in that bin into their corresponding tcachebin **until it is full**, as shown in Figure 12 below.

When an **unsortedbin** scan occurs, malloc dumps any **exact-fitting** chunks it finds into their corresponding tcachebin. If the target tcachebin is full and malloc finds another exact-fitting chunk in the unsortedbin, that chunk is allocated.  If the unsortedbin scan is completed and one or more chunks were dumped into a tcachebin, a chunk is allocated from that tcachebin.
<br></br>
# Appendix:  
[tcache dump CTF challange - bctf2018 atum](https://github.com/Hi-Im-darkness/CTF/tree/master/bctf2018/pwn/atum)
[tcache dump - (v2.29-v2.31)](https://www.fatalerrors.org/a/tcache-stash-fastbin-double-free.html)  


[glibc v2.29 TCache Double Free mitigation bypass technique when double free and an intermediate memory corruption is possible](https://drive.google.com/file/d/1g2qIENh2JBWmYgmfTJMJUier8w0XAGDt/view)  



[tcache related challange 1](https://faraz.faith/2019-10-12-picoctf-2019-heap-challs/)
[tcache related challange 2](https://payatu.com/blog/Gaurav-Nayak/introduction-of-tcache-bins-in-heap-management)  

[Remote Code Execution via Tcache Poisoning - SANS SEC 760 "Baby Heap" CTF](https://www.youtube.com/watch?v=43ewpRBIRgA)
