https://libc.rip/
https://github.com/niklasb/libc-database

Show only the code context:
set context-sections code 

Print the context we defined:
context

vmmap - show memory map for this process

show the heap chunks:
vis-heap-chunks/vis

print/p a

quit/CTRL-D

|Checksec|:
--------------
partial relro - changes program's sections layout in memory
full relro- like partial but also maps some of these sections as read only after initialization
		(icluding the PLT and fini-array)

NX/DEP - enforces whether pages of memory can be treated as executable code

PIE -position independent executable :
	NO - We can know the at run time the process address (static location)
	YES - the binary is subject to ASLR and you'll need to leak some address of the heap/ libc addr
ASLR -process's stack heap & libraries will be loaded at random addresses

RUNPATH - the binary will go and look inside this path for libraries like libc (a user can control the file)

show/search commands:
--------------------------------
pwndbg
pwndbg search-term

run a process in gdb (no breakpoints), then whenever you want to return to gdb- hit CTRL-C
when a process is started under gdb, ASLR is disabled??

dq/dump quadword label
xinfo label - show where the variable is stored (what section)

house of force- no integrity check on the size field of the top chunk

it doesn't matter which version of glibc the binary was compiled with
but what version is available on the OS
the vulnerability depends on what platform the binary runs on

vmmap search_term
vmmap libc

VIM command to run the file:
:!./%
!-shell command is next
%-name of this buffer

:!./% GDB - attach GDB to it and open a second terminal right before the interactive() command
ALT + `  - switch between terminals
It will attach gdb to the already running process, rather than starting it under gdb
So it will get affected by ASLR!

:41,50d | 42,44d - will delete the log.info lines from the script

:!./% GDB NOASLR


libc has its own plt alongside two other structures called __exit_funcs & tls_dtor_list

glibc plt is writeable throughout the program lifetime, but it's hard to trigger calls to the functions within it

 __exit_funcs & tls_dtor_list are protected by Pointer guard

 malloc hooks (malloc core functions = func pointer in glibc data section)


 dq &__malloc_hook-2

next(libc.search(b"/bin/sh"))


!dq -run the last dq style command

dq &main_arena 20

the fastbins are the exceptions for the previnuse


ptype StructName

abort -> we invoked some of libc heap mitigations
use f/frame to check what happend
f 4 = switch to frame _int_free()

context code

glibc has better protections

One_gadget:
----------
find_fake_fast &__malloc_hook

script option

----------------------------------------------------------------


db = dumpbytes (like hexdump)

vim :%s/0x28/0x68/g

u __malloc_hook  = derefference the malloc hook (show the assembly)

normally - the path to will be constant for all binaries on the system
but because our binaries are linked to a specific glibc version,
we need to use this one liner
one_gadget $(ldd fastbin_dup|grep libc.so|cut -d' ' -f3)
it will print the offset from the beginnig of the libc so
for each gadget

p/x av->system_mem
dq av->top

sudo chown root:root binary_name (setuid bit)

vmmap libc

vis 3 - without large chunk (410)

xinfo &target

mp - mp struct

calloc doesnt use tcache

bins

set context-source-code-lines 50
set listsize 50
list malloc.c:linenumber

!list - run last list command

man mallopt -> /env
you can modify environment variables  per program / per shell session (export)
or from gdb : set environment varname =
malloc paramerters which are set through environment variables takes effect only once mallloc has been initialized	

within GDB:
glibc tunables
p tunable_list[21]

unset environment .....

set environment GLIBC_TUNABLES = glibc.malloc.tcache_count = 0

vmmap [heap]

ds address (dump symbol?)

$(ldd /bin/ls|grep libc.so|cut -d' ' -f3)


guard chunk to avoid consolidation with the top chunk

xinfo target

p *((struct malloc_chunk*)addr).fd

^fd^bk - run the last command but replace fd with bk

dq mp_.sbrk_base
freetuts.download

  printf("puts() @ %p\n", &puts, argv);
  m = (char *)malloc(0x88uLL);
  printf("heap @ %p\n", m - 16);
  free(m);

atoi() @ 0x7fcef9edf5c0
system @ 0x7fcef9eeb700
heap @ 0x5603d8101410

# DIFF LOCAL
libcdiff = 0x34260
sysdiff = 0x3f460

# DIFF REMOTE
libcdiff = 0x39ea0
sysdiff = 0x46590

lic start- 601fe8
atoi 601ff8 ,201fe8!!!
system 4f550
atoi - 407a0 - 0x7ffff7a5a5c0

context.update( arch =='amd64')
printf_got = e.got[ got['

set {int}addr1 = addr2 (gdb)

info proc mapping = vmmap

0x7ffff7a227a0 <atoi>:                  0x08ec8348             0x602078
0x7ffff7a31550 <__libc_system>:         0x74ff8548 -602050
0x7ffff7a03b10 <__libc_start_main>:     0x54415541 -5c81d8


sudo id

vulnerabilities, mitigations
mktmpenv -p