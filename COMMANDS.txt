
add the following macro to .bashrc:
-------------------------------------
a macro that gets libc build number for one_gadget:
libc() {ldd $1 | grep libc.so | cut -d' ' -f3}
-------------------------------------

[we can call zsh/bash from within pwndbg]
>one_gadget $(libc binary_name)

nm $(libc binary_name) -D | grep "__.*_hook" - get the dynamic symbols within a binary, then grep

ltrace -e \*alloc ./file_name - trace only libc function that ends with alloc

Show only the code context:
set context-sections code 

Print the context we defined:
context

vmmap - show memory map for this process

show the heap chunks:
vis-heap-chunks/vis

print/p a

quit/CTRL-D

|Checksec|:
--------------
partial relro - changes program's sections layout in memory
full relro- like partial but also maps some of these sections as read only after initialization
		(icluding the PLT and fini-array)

NX/DEP - enforces whether pages of memory can be treated as executable code

PIE -position independent executable :
	NO - We can know the at run time the process address (static location)
	YES - the binary is subject to ASLR and you'll need to leak some address of the heap/ libc addr
ASLR -process's stack heap & libraries will be loaded at random addresses

RUNPATH - the binary will go and look inside this path for libraries like libc (a user can control the file)

show/search commands:
--------------------------------
pwndbg
pwndbg search-term

run a process in gdb (no breakpoints), then whenever you want to return to gdb- hit CTRL-C
when a process is started under gdb, ASLR is disabled??

dq/dump quadword label
xinfo label - show where the variable is stored (what section)

house of force- no integrity check on the size field of the top chunk

it doesn't matter which version of glibc the binary was compiled with
but what version is available on the OS
the vulnerability depends on what platform the binary runs on

vmmap search_term
vmmap libc

VIM command to run the file:
:!./%
!-shell command is next
%-name of this buffer

:!./% GDB - attach GDB to it and open a second terminal right before the interactive() command
ALT + `  - switch between terminals
It will attach gdb to the already running process, rather than starting it under gdb
So it will get affected by ASLR!

:41,50d | 42,44d - will delete the log.info lines from the script

:!./% GDB NOASLR


libc has its own plt alongside two other structures called __exit_funcs & tls_dtor_list

glibc plt is writeable throughout the program lifetime, but it's hard to trigger calls to the functions within it

 __exit_funcs & tls_dtor_list are protected by Pointer guard

 malloc hooks (malloc core functions = func pointer in glibc data section)


 dq &__malloc_hook-2

next(libc.search(b"/bin/sh"))


!dq -run the last dq style command

dq &main_arena 20

the fastbins are the exceptions for the previnuse


ptype StructName - print struct layout (like in c code), need to be in the relevant frame

abort -> we invoked some of libc heap mitigations
use f/frame to check what happend
f 4 = switch to frame _int_free()

context code

glibc has better protections

One_gadget:
----------
find_fake_fast &__malloc_hook

script option

----------------------------------------------------------------


db = dumpbytes (like hexdump)

vim :%s/0x28/0x68/g

u __malloc_hook  = derefference the malloc hook (show the assembly)

normally - the path to will be constant for all binaries on the system
but because our binaries are linked to a specific glibc version,
we need to use this one liner
one_gadget $(ldd fastbin_dup|grep libc.so|cut -d' ' -f3)
it will print the offset from the beginnig of the libc so
for each gadget

p/x av->system_mem
dq av->top

sudo chown root:root binary_name (setuid bit)

vmmap libc

vis 3 - without large chunk (410)

xinfo &target

mp - mp struct

calloc doesnt use tcache

bins

set context-source-code-lines 50
set listsize 50
list malloc.c:linenumber

!list - run last list command

man mallopt -> /env
you can modify environment variables  per program / per shell session (export)
or from gdb : set environment varname =
malloc paramerters which are set through environment variables takes effect only once mallloc has been initialized	

within GDB:
glibc tunables
p tunable_list[21]

unset environment .....

set environment GLIBC_TUNABLES = glibc.malloc.tcache_count = 0

vmmap [heap]

ds address (dump symbol?)

$(ldd /bin/ls|grep libc.so|cut -d' ' -f3)


guard chunk to avoid consolidation with the top chunk

xinfo target

p *((struct malloc_chunk*)addr).fd

^fd^bk - run the last command but replace fd with bk

A quick way to find the start of the default heap:
dq mp_.sbrk_base num_of_qwords

  printf("puts() @ %p\n", &puts, argv);
  m = (char *)malloc(0x88uLL);
  printf("heap @ %p\n", m - 16);
  free(m);


set {int}addr1 = addr2 (gdb)

info proc mapping = vmmap

To inspect instructions at the address the malloc hook points to you can omit the ampersand altogether like this 
(dissassembly)
pwndbg> u __malloc_hook
pwndbg> u __free_hook
sudo id

vulnerabilities, mitigations
mktmpenv -p