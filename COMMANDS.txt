VIM
----------------------------
VIM command to run the file:
:!./%
!-shell command is next
%-name of this buffer

:!./% GDB - attach GDB to it and open a second terminal right before the interactive() command
It will attach gdb to the already running process, rather than starting it under gdb
So it will get affected by ASLR!

:41,50d | 42,44d - will delete the log.info lines from the script

:!./% GDB NOASLR - (both argument are handled by pwntools within our python script)
:%s/0x28/0x68/g

run a process in gdb (no breakpoints), then whenever you want to return to gdb- hit CTRL-C

when a process is started under gdb, ASLR is disabled


add the following macro to .bashrc:
-------------------------------------
a macro that gets libc build number for one_gadget:
libc() {ldd $1 | grep libc.so | cut -d' ' -f3}
-------------------------------------

[we can call zsh/bash from within pwndbg]
>one_gadget $(libc binary_name)

nm $(libc binary_name) -D | grep "__.*_hook" - get the dynamic symbols within a binary, then grep

Library function calls tracing:
----------------------------------
ltrace -e \*alloc ./file_name - trace only libc function that ends with alloc

Context command:
-------------------------
(compile with -g for displaying source code when debugging):
set context-sections code -Show only the code context




Binary security mitigations |Checksec command output|:
-----------------------------------------------
partial relro - changes program's sections layout in memory
full relro- like partial but also maps some of these sections as read only after initialization
		(icluding the PLT and fini-array)

NX/DEP - enforces whether pages of memory can be treated as executable code

PIE -position independent executable :
	NO - We can know the at run time the process address (static location)
	YES - the binary is subject to ASLR and you'll need to leak some address of the heap/ libc addr

ASLR - process's stack heap & libraries will be loaded at random addresses

RUNPATH - the binary will go and look inside this path for libraries like libc (a user can control the file)
-----------------------------------------------

dq/dump quadword label
xinfo label - show where the variable is stored (what section i)


it doesn't matter which version of glibc the binary was compiled with
but what version is available on the OS
the vulnerability depends on what platform the binary runs on

vmmap search_term
for example:
vmmap libc - show virtual memory sections with the label 'libc' 
vmmap heap

ALT + `  - switch between terminals

next(libc.search(b"/bin/sh"))


the fastbins are the exceptions for the previnuse


ptype StructName - print struct layout (like in c code), need to be in the relevant frame

context code


One_gadget:
----------
find_fake_fast &__malloc_hook

script option


One_gadget:
--------------------
normally - the path to will be constant for all binaries on the system
but because our binaries are linked to a specific glibc version,
we need to use this one liner
one_gadget $(ldd fastbin_dup|grep libc.so|cut -d' ' -f3)
it will print the offset from the beginnig of the libc so
for each gadget

p/x av->system_mem
dq av->top

sudo chown root:root binary_name (setuid bit)

vis 3 - without large chunk (410)

xinfo &target

bins

set context-source-code-lines 50
set listsize 50
list malloc.c:linenumber

!list - run last list command

ds address (dump symbol?)

$(ldd /bin/ls|grep libc.so|cut -d' ' -f3)



xinfo target




how to leak addresses of libc and the heap within your C code (easy):
  printf("puts() @ %p\n", &puts, argv);
  m = (char *)malloc(0x88uLL);
  printf("heap @ %p\n", m - 16);
  free(m);





